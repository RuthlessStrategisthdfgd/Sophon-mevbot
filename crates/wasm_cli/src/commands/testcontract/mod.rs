use anyhow::{anyhow, Result};
use bonsaidb::{
    core::{connection::StorageConnection, schema::SerializedView},
    local::Storage,
};
use clap::Parser;
use serde_json;
use std::{collections::HashMap, path::PathBuf};
use telemetry::info;
use versatus_rust::versatus_rust::{
    AccountInfo, Address, ContractInputs, ProtocolInputs, SmartContractInputs,
};
use wasm_runtime::{
    metering::{cost_function, MeteringConfig},
    wasm_runtime::WasmRuntime,
};
use wasmer::{Cranelift, Target};

use crate::commands::testinitdb;

use super::{testbalance::get_balance, testinitdb::AccountAddress};

#[derive(Parser, Debug)]
pub struct TestContractOpts {
    /// This is the path to the database to be created/used. #716, this path is what we'll feed
    /// into the database driver.
    #[clap(short, long)]
    pub dbpath: String,
    /// The path to the WASM object file to load and describe
    #[clap(short, long, value_parser, value_name = "FILE")]
    pub wasm: PathBuf,
    /// The function to call within the smart contract. #716 this will influence the JSON we
    /// generate below to pass into the smart contract when we execute it. TODO: mg@ needs to also
    /// remember to add some function-specific arguments here to allow those to be passed in.
    #[clap(short, long, value_parser, value_name = "FUNCTION")]
    pub function: String,
    /// The arguments to pass into the function as a JSON object. See the `versatus-rust` github
    /// repository for the inputs that supported functions take. For now, this is a string
    /// interpretted as a JSON object, whereas later, it'll likely be more formal. #716, this JSON
    /// will equate to the data in the FunctionInputs enum here:
    /// https://github.com/versatus/versatus-rust/blob/main/src/versatus_rust.rs#L94
    #[clap(short, long, value_parser, value_name = "JSON", default_value = "[]")]
    pub inputs: String,
    /// An environment variable to pass to the running WASM module. May be used
    /// multiple times.
    #[clap(short, long, value_parser, value_name = "KEY=VALUE")]
    pub env: Vec<String>,
    /// The initial limit of credits that the WASM module's meter will use to track
    /// operation expenses.
    #[clap(short = 'l', long, value_parser, value_name = "UINT64")]
    pub meter_limit: u64,
    /// Remaining arguments (after '--') are passed to the WASM module command
    /// line.
    #[clap(last = true)]
    pub args: Vec<String>,
}

/// Read and parse a WASM object and print high level information that is
/// targeted toward developers of WASM modules. It should attempt to describe
/// how the module might, or might not, be viable as an off-chain smart contract
/// compute job.
pub fn run(opts: &TestContractOpts) -> Result<()> {
    let wasmfile = opts
        .wasm
        .to_str()
        .ok_or(anyhow!("Failed to convert WASM filename to valid string."))?;
    let wasm_bytes = std::fs::read(wasmfile)?;
    info!(
        "Loaded {} bytes of WASM data from {} to execute.",
        wasm_bytes.len(),
        wasmfile
    );
    let mut env_vars: HashMap<String, String> = HashMap::new();
    for var in opts.env.iter() {
        if let Some((key, value)) = var.split_once('=') {
            env_vars.insert(key.to_string(), value.to_string());
        }
    }

    let storage_connection = testinitdb::open_storage(&opts.dbpath)?;

    let target = Target::default();
    // Test the WASM module.
    let mut wasm = WasmRuntime::new::<Cranelift>(
        &target,
        &wasm_bytes,
        MeteringConfig::new(opts.meter_limit, cost_function),
    )?
    .stdin(
        &serde_json::to_string(&create_contract_inputs(
            &opts.function,
            &opts.inputs,
            &storage_connection,
        )?)?
        .into_bytes(),
    )
    .env(&env_vars)
    .args(&opts.args);
    wasm.execute()?;

    // #716 We shouldn't print the output here, but rather parse it and use it to update the
    // database. For example, if an ErcTransferEvent is part of the output(https://github.com/versatus/versatus-rust/blob/main/src/eip20.rs#L48), we should move the balance from the from account to the to account.
    println!("{}", &wasm.stdout());
    // TODO: Update storage with the output of the contract

    eprintln!("Contract errors: {}", &wasm.stderr());

    Ok(())
}

// #716 This JSON string is a placeholder to allow the code to compile. What we need to do is
// to build the JSON to match the JSON generated by the example in the versatus-rust
// repository, but build it from the contents of the database and command line inputs. We can
// assume (for now) that all contracts will be ERC20 when dealing with inputs and outputs.
fn create_contract_inputs(
    function: &str,
    inputs: &str,
    storage_connection: &bonsaidb::local::Storage,
) -> Result<SmartContractInputs> {
    let (latest_version, (block_height, block_time)) = get_protocol_inputs(storage_connection)?;
    let raw_address = Address([2; 20]);
    let account_address = AccountAddress {
        address: raw_address.0,
    };
    let balance_document = get_balance(&account_address, storage_connection)?;
    let account_balance = balance_document.contents.value;

    Ok(SmartContractInputs {
        version: latest_version,
        account_info: AccountInfo {
            account_address: (raw_address), // TODO: is this the sender or receiver?
            account_balance,
        },
        protocol_input: ProtocolInputs {
            version: (latest_version),
            // TODO: Figure out how to increment block height & time
            block_height: (block_height + 1),
            block_time: (block_time + 1),
        },
        contract_input: ContractInputs {
            contract_fn: (function.to_owned()),
            function_inputs: serde_json::from_str(inputs).expect("oof"), // deserialize json into FunctionInputs
                                                                         // .map_err(|e| anyhow!("failed to deserialize function inputs: {e:?}"))?,
        },
    })
}

fn get_protocol_inputs(storage_connection: &Storage) -> Result<(i32, (u64, u64))> {
    let protocol_db =
        storage_connection.database::<testinitdb::ProtocolInputs>("protocol-inputs")?;
    let protocol_view = testinitdb::ProtocolView::entries(&protocol_db)
        .ascending()
        .query()?;
    let protocol_document = protocol_view
        .last()
        .expect("found empty protocol inputs database");
    let latest_version = protocol_document.key + 1;
    let (block_height, block_time) = protocol_document.value;
    Ok((latest_version, (block_height, block_time)))
}

#[test]
fn test_create_contract_inputs() {
    let storage =
        testinitdb::open_storage(&"./bonsaidb".to_string()).expect("could not open storage");
    let contract_inputs = create_contract_inputs(
        "transfer",
        "{\
		    \"erc20\": {
		        \"transfer\": {
		    	\"value\": \"0xffff\",
		    	\"address\": \"0x0303030303030303030303030303030303030303\"
		        }
		    }
	    }",
        &storage,
    );
    assert!(contract_inputs.is_ok());
}
